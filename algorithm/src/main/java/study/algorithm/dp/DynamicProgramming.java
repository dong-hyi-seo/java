package study.algorithm.dp;

/**
 * @author donghyi.seo
 * @since 2022-12-28
 * 참고 : https://sskl660.tistory.com/87
 * 피보나치 수열 : 첫째항과 둘째항이 1의 값을 가지고, 그뒤의 모든 항은 바로 앞 두항의 합으로 구성된 수열을 말한다. 예를들면, 다음과 피보나치 수열은 다음과 같이
 * 진행된다. 1, 1, 2, 3, 5, 8, 13, 21 ....
 *
 * 동적계획법....
 * 전체저인 과정의 값을 모두 기억해가며 풀어가는 방식이 동적계획법의 정석
 * 아래 경우들과 마찬가지로 데이터를 어떤 방식으로 기억할 지(단순히 변수에 담을지 n차원 배열에 담을지, 트리 자료구조에 담을지 ..)는 문제에 따르게 다르게 생각하면 된다.
 * 실제로 데이터를 어떤 방시으로 저장할지를 생각하는 것이 동적 계획법의 출발이고, 알고리즘 실력을 기르는 중요한 요소!
 *
 * 동적계획법 문제 접근 방식
 * 1. 문제를 특정한 부분문제로 나누고, 해당 부분 문제의 최적해들을 지정할 dp테이블을 정의해본다.
 * -> 이를테면 앞의 서울에서 부산까지 가는 최단 경로를 구하는 예시를 기준으로 생각해보면, 'n번째 지역까지 가는데 필요한 최단 경로' 라는 부분문제를 생각해 볼 수 있고,
 * 이를 1차원 배열에 저장하면 되겠다는 생각을 해볼 수 있다.
 * -> 쉽게 말해 부분 문제를 무엇으로 둘거고, 그걸 어떻게 저장해볼까를 생각하는 단계!
 *
 * 2. 부분 문제의 관계를 생각하며 점화식을 도출한다.
 * -> 이를테면 앞의 서울에서 부산까지 가는 최단경로를 구하는 예시를 기준으로 생각해보면 dp[n] = dp[n-1] + (n-1지역에서 n으로 가는 최단거리) 라는 점화식을 세울 수 있음을 알수있다.
 * -> 쉽게 말해 해당 부분문제의 규칙성을  파악해보고, 점화식과 기저조건을 정의하는 단계이다. 물론... 규칙성을 찾는것이 말처럼 쉽지않을것
 *
 * 3. 점화식을 바탕으로 dp 테이블을 갱신하면서 최종적으로 전체 문제를 해결한다.
 * -> 이를 테면 앞의 서울에서 부산까지 가는 최단 경로를 구하는 예시를 기준으로 생각해보면 결국 dp[n]의 값이 최종 답이 되는 것을 확인할수 있다.
 * -> 사실 이단계는 확인하는 단계이다. 데이터를 저장할 dp테이블 설계와 각 데이터간의 연관성을 바탕으로 점화식을 잘 정의 하였다면 올바른 답이 도출되는것을 확인할수 있을것
 */
public class DynamicProgramming {

    /**
     * 피보나치수열 일반적인 재귀호출
     * n 값을 100으로만 줘도 엄청 오래걸림 ~
     *
     * 왜 ?
     * f(4)를 구하려고할때 f(1), f(2) 등의 이미 계산했던것을 또 계산하게 되어있음 한번만하면되는데 .. 이때매 느림
     */
    public long fibonacciNormal(int n) {
        if (n == 1 || n == 2) {
            return 1;
        }
        //점화식
        return fibonacciNormal(n-1) + fibonacciNormal(n-2);
    }

    /**
     * 피보나치 수열 DP (Top Down) 풀기
     * 위 fibonacciNormal을 통해서 푼문제점을 해결해보자
     * 위는 f(4)를 계산할때 f(3) 전 피보나치함수에서 똑같은 것을 수행을 지수배만큼하기때문에 비효율적이다.
     * 일반적으로 재귀를 사용하는 구조는 같지만, 부분문제에서 구한 값을 기억(Memoization)하면서 다음재귀에서 재활용하는 과정을 추가해주면된다.
     * 위 함수보다 엄청 빨라진것을 확인 할수있음
     */
    static long[] dp;
    public long fibonacciTopDownDpRun(int n) {
        dp = new long[n + 1];
        return fibonacciTopDownDp(n);
    }
    private long fibonacciTopDownDp(int n) {
        if (n == 1 || n == 2){
            return dp[n] = 1;
        }

        //만일, 저장된 값이 존재하는 경우 기억된 값을 바로 넘겨준다.
        if (dp[n] != 0) {
            return dp[n];
        } else { //그렇지 않은경우, 기저 조건까지 내려가서 구해진 값을 저장하면서 재귀를 전이한다.
            return dp[n] = fibonacciTopDownDp(n-1) + fibonacciTopDownDp(n - 2);
        }
    }


    /**
     * 피보나치 수열 DP (Bottom Up) 풀기
     * 이부분은 위 Top Down Dp 방식에서 좀더 개선한 방식이다.
     * 부분 문제에서 해결한 값을 저장(Tabulation)하면서 문제를 해결하는 경우 불필요한 계산 과정을 줄여주기 떄문에
     * 엄청난 속도 향상을 보임을 알 수 있다.
     * 아래에서는 굳이 값을 저장하지 않더라도 반복문을 적용하여 앞의 두값만 기억하고 있다면 굳이 메모리 공간을 낭비하지 않더라도 결과를 계산할수 있다는 말이다.
     *
     */
    public long fibonacciBottomUpDpRun(int n) {
        dp = new long[n + 1];
        //기저 조건을 바탕으로 초항을 먼저 초기화
        dp[1] = 1;
        dp[2] = 1;

        //n 번쨰 피보나치 수를 구하고출력
        return fibonacciBottomUp(n);
    }

    private long fibonacciBottomUp(int n) {
        //기저 조건을 기반으로 테이블을 채워나간다 (Tabulation)
        for (int i = 3; i<=n; i++) {
            //점화식을 이용하여 쉽게 구할수 있음
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }

}
